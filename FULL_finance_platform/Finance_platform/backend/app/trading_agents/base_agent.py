"""
Base Trading Agent Framework

Research-based algorithmic trading agent architecture supporting
multiple strategies and execution patterns.
"""

from abc import ABC, abstractmethod
from enum import Enum
from typing import Dict, List, Optional, Any
from datetime import datetime
import logging
from dataclasses import dataclass, field

logger = logging.getLogger(__name__)


class AgentType(Enum):
    """Types of trading agents based on research strategies"""
    MEAN_REVERSION = "mean_reversion"
    MOMENTUM = "momentum"
    STATISTICAL_ARBITRAGE = "statistical_arbitrage"
    LSTM_PREDICTION = "lstm_prediction"
    REINFORCEMENT_LEARNING = "reinforcement_learning"
    PAIRS_TRADING = "pairs_trading"
    VOLATILITY_ADJUSTED = "volatility_adjusted"
    ENSEMBLE = "ensemble"


class SignalType(Enum):
    """Trading signal types"""
    BUY = "buy"
    SELL = "sell"
    HOLD = "hold"
    STRONG_BUY = "strong_buy"
    STRONG_SELL = "strong_sell"


@dataclass
class TradingSignal:
    """Trading signal generated by an agent"""
    signal_type: SignalType
    confidence: float  # 0.0 to 1.0
    symbol: str
    timestamp: datetime
    price: Optional[float] = None
    quantity: Optional[int] = None
    reasoning: str = ""
    metadata: Dict[str, Any] = field(default_factory=dict)


@dataclass
class MarketData:
    """Market data structure for agents"""
    symbol: str
    timestamp: datetime
    open: float
    high: float
    low: float
    close: float
    volume: int
    additional_data: Dict[str, Any] = field(default_factory=dict)


@dataclass
class AgentPerformance:
    """Performance metrics for trading agents"""
    total_trades: int = 0
    winning_trades: int = 0
    losing_trades: int = 0
    total_pnl: float = 0.0
    win_rate: float = 0.0
    sharpe_ratio: float = 0.0
    max_drawdown: float = 0.0
    avg_trade_duration: float = 0.0
    last_updated: Optional[datetime] = None


class BaseTradingAgent(ABC):
    """
    Abstract base class for all trading agents

    Based on research from:
    - Deep Learning for Algorithmic Trading (ScienceDirect, 2025)
    - Multi-Agent Deep Reinforcement Learning (ACM, 2024)
    - Statistical Arbitrage Research (SSRN)
    """

    def __init__(
        self,
        agent_id: str,
        agent_type: AgentType,
        config: Optional[Dict[str, Any]] = None
    ):
        self.agent_id = agent_id
        self.agent_type = agent_type
        self.config = config or {}
        self.is_active = False
        self.performance = AgentPerformance()
        self.last_signal: Optional[TradingSignal] = None
        logger.info(f"Initialized {agent_type.value} agent: {agent_id}")

    @abstractmethod
    def analyze(self, market_data: List[MarketData]) -> TradingSignal:
        """
        Analyze market data and generate trading signal

        Args:
            market_data: Historical and current market data

        Returns:
            TradingSignal with agent's recommendation
        """
        pass

    @abstractmethod
    def train(self, historical_data: List[MarketData]) -> None:
        """
        Train the agent on historical data (if applicable)

        Args:
            historical_data: Historical market data for training
        """
        pass

    def update_performance(self, trade_result: Dict[str, Any]) -> None:
        """
        Update agent performance metrics

        Args:
            trade_result: Dictionary containing trade outcome
        """
        self.performance.total_trades += 1
        pnl = trade_result.get('pnl', 0.0)
        self.performance.total_pnl += pnl

        if pnl > 0:
            self.performance.winning_trades += 1
        elif pnl < 0:
            self.performance.losing_trades += 1

        # Calculate win rate
        if self.performance.total_trades > 0:
            self.performance.win_rate = (
                self.performance.winning_trades / self.performance.total_trades
            )

        self.performance.last_updated = datetime.now()
        logger.info(f"Agent {self.agent_id} performance updated: {self.performance}")

    def start(self) -> None:
        """Start the trading agent"""
        self.is_active = True
        logger.info(f"Agent {self.agent_id} started")

    def stop(self) -> None:
        """Stop the trading agent"""
        self.is_active = False
        logger.info(f"Agent {self.agent_id} stopped")

    def get_performance(self) -> AgentPerformance:
        """Get current performance metrics"""
        return self.performance

    def get_status(self) -> Dict[str, Any]:
        """Get agent status"""
        return {
            "agent_id": self.agent_id,
            "agent_type": self.agent_type.value,
            "is_active": self.is_active,
            "performance": {
                "total_trades": self.performance.total_trades,
                "win_rate": self.performance.win_rate,
                "total_pnl": self.performance.total_pnl,
                "sharpe_ratio": self.performance.sharpe_ratio
            },
            "last_signal": {
                "type": self.last_signal.signal_type.value,
                "confidence": self.last_signal.confidence,
                "timestamp": self.last_signal.timestamp.isoformat()
            } if self.last_signal else None
        }


class AgentRegistry:
    """Registry for managing multiple trading agents"""

    def __init__(self):
        self.agents: Dict[str, BaseTradingAgent] = {}
        logger.info("Agent registry initialized")

    def register(self, agent: BaseTradingAgent) -> None:
        """Register a new agent"""
        self.agents[agent.agent_id] = agent
        logger.info(f"Registered agent: {agent.agent_id}")

    def unregister(self, agent_id: str) -> None:
        """Unregister an agent"""
        if agent_id in self.agents:
            del self.agents[agent_id]
            logger.info(f"Unregistered agent: {agent_id}")

    def get_agent(self, agent_id: str) -> Optional[BaseTradingAgent]:
        """Get agent by ID"""
        return self.agents.get(agent_id)

    def get_all_agents(self) -> List[BaseTradingAgent]:
        """Get all registered agents"""
        return list(self.agents.values())

    def get_active_agents(self) -> List[BaseTradingAgent]:
        """Get all active agents"""
        return [agent for agent in self.agents.values() if agent.is_active]

    def get_agents_by_type(self, agent_type: AgentType) -> List[BaseTradingAgent]:
        """Get all agents of a specific type"""
        return [
            agent for agent in self.agents.values()
            if agent.agent_type == agent_type
        ]


# Global agent registry
agent_registry = AgentRegistry()
